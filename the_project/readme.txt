分工：
王越-202100460102：1 2 3 4 5
赵正一-202100460049 ： 7 8 9 10 11 12 
王荥耀 202100460063 ： 13 14 15 16
朱朕 202100460050 ：18 19 20 21 22

Project1: implement the naïve birthday attack of reduced SM3

实现内容与技巧：使用了openssl库的SM3算法。
以加密结果的前32bit为例，当作简单SM3来进行破解。
代码采取了用空间换时间的方法，将经过的点转换为整型，再用map储存查找。

运行时间：0.296s

Project2: implement the Rho method of reduced SM3

实现内容与技巧：同样使用openssl库来调用SM3，利用加密结果前32bit作为简单SM3。
由于为了快速步入循环并找到重复，算法采取了大小步方式，一个正常便利循环，一个在另一个多次循环后再进行移动一次。

运行时间：0.169s

Project3: implement length extension attack for SM3, SHA256, etc.

实现内容和技巧：这里以SM3为例进行扩展攻击，攻击以openssl库调用SM3算法得到的结果为正确值，对自己构造的SM3扩展加密的结果进行对比。
由于需要对SM3加密内容进行扩展和加密，所以要构造明文扩展，密钥的轮函数，明文拼接，格式转换等多个方面。

运行时间：0.362s

Project4: do your best to optimize SM3 implementation (software)

实现内容和技巧：基础的SM3构造在Project3中已经完成，当时加密一次大概需要1.624s的时间，在此基础上进行加速。
经过时间测试发现对于ModAdd，LeftShift两个模块的调用运行时间最长，于是对两模块进行优化。

运行时间：0.062s

Project5: Impl Merkle Tree following RFC6962

实验内容和技巧：我认为是在遵循RFC6962的基础上实现Merkle Tree。除开基础的sha-256，Merkle Tree实现了对多个数据进行加密整合，大幅度的压缩体积减少空间消耗。

运行时间：11.86s

Project7: Try to Implement this scheme

实现内容：这个项目我并没有非常清楚地想明白具体要做什么，在查找有关资料后，我仅仅完成了生成最小支配分区（MDP）的算法。
技巧与创新点：我使用了自定义的动态数组结构 struct Vector 来存储返回的向量，因为C语言没有直接的向量类型，同时在 push_back 函数中，当动态数组的大小超出容量时，使用 realloc 进行重新分配，可以减少内存频繁分配和释放的次数，提高性能，并且通过使用 capacity 变量来控制动态数组的大小，以便在必要时动态增加容量。这可以避免频繁的内存重新分配，提高性能。

Project8: AES impl with ARM instruction

运行时间：
由于是arm指令集，与笔记本的intel架构不同，需要交叉编译运行，但是尝试了很多方法依旧无法对代码进行调试。

实现内容：
该代码实现了AES-128加密算法的 ARMv8 架构优化版本。AES（Advanced Encryption Standard）是一种常用的对称加密算法，用于保护敏感数据的机密性。在这个实现中，使用了ARM NEON指令集来加速加密过程。首先，定义了一个固定的Rcon（Round Constant）数组，Sbox（Substitution Box）数组和一些常量。ase128_enc_armv8 函数实现了AES-128的加密过程。该函数使用ARM NEON指令来优化计算。具体来说，它将输入数据分成128位（16字节）的数据块，并根据预生成的轮密钥进行加密。在每一轮中，通过使用AES指令来执行逐位的状态混淆和轮密钥的XOR操作，以实现加密。最终的加密结果存储在输出数组 ou 中。aes128_dec_armv8 函数实现了AES-128的解密过程，类似于加密函数，但使用不同的AES指令和密钥。generate_AES_keys 函数用于生成AES加密过程中所需的轮密钥。它从输入的16字节密钥生成44个32位的轮密钥。该函数使用了密钥扩展算法，通过循环左移、S盒替换和轮常数与轮密钥的异或操作来生成轮密钥。main 函数演示了如何使用上述函数进行AES-128加密。首先，定义了输入数据和AES密钥。然后，生成轮密钥，最后调用 ase128_enc_armv8 函数进行加密，并将结果存储在输出数组中。

创新点和技巧：
代码中的创新点在于使用了ARM NEON指令集进行加速。ARM NEON是一组SIMD（单指令，多数据）指令，可同时处理多个数据元素，提高了加密算法的并行性能。通过使用密钥扩展算法，代码生成了整个AES加密过程中所需的轮密钥，避免了在每一轮中重复计算轮密钥。代码使用了合适的数据类型和数据结构，如 uint8x16_t 类型来表示128位数据块，并利用指针操作进行数据的加载和存储，以提高计算效率。

roject9: AES / SM4 software implementation

SM4：
运行时间：0.000005 seconds

实现内容与技巧：
该代码实现了 SM4 加密算法的 ECB（Electronic Codebook）模式加解密功能，并且通过性能计数器 QueryPerformanceCounter 计算了加解密操作的运行时间。SM4 是一种对称加密算法，是中国国家密码管理局发布的国密算法之一。实现了以下功能：
定义了一些常量、宏和数据结构，用于实现 SM4 加解密算法。
实现了 S-box 变换和轮函数中的 FK 和 CK 常量的定义。
实现了 s_box_change 函数，用于进行 S-box 变换。
实现了 sm4_fk 函数，对一个输入进行 S-box 变换并与位移操作后的结果进行异或。
实现了 sm4_round 函数，对一个输入进行 S-box 变换并与多次位移操作和轮密钥异或操作后的结果进行异或。
实现了 sm4_set_key 函数，用于生成 SM4 加密的轮密钥。
实现了 sm4_crypt_ecb 函数，用于对 16 字节的数据块进行 ECB 模式的加解密。
在 main 函数中，通过定义密钥和输入数据，进行了 SM4 加密和解密操作，并通过 QueryPerformanceCounter 计算了加解密操作的运行时间。
验证加密结果是否正确，如果加密结果与预期的结果不符，输出测试失败。

AES：
运行时间：0.001993 seconds

实现内容与技巧：
该代码实现了AES-128加密算法的功能
导入模块和定义常量：代码开始部分导入了需要的模块，如numpy和time。还定义了S盒、轮常量、列混合矩阵等AES算法中使用的常量。
文本转换函数：text函数将输入的字符串转换为128位的ASCII表示，用作明文和密钥。
字节代换和行移位：SubBytes函数根据S盒进行字节代换操作，ShiftRows函数对状态进行行移位。
有限域Galois乘法：galoismul函数实现了有限域Galois乘法操作，用于列混合中的乘法运算。
列混合：MixColumns函数实现了列混合操作，利用有限域乘法将状态矩阵的每一列进行混合。
轮密钥产生：T函数用于生成轮密钥，KeyExpansion函数根据主密钥生成轮密钥数组。
轮密钥加：AddRoundKey函数实现了轮密钥加操作，将轮密钥与状态矩阵进行异或。
AES加密函数：aes函数实现了AES的加密过程，包括字节代换、行移位、列混合、轮密钥加等步骤。
性能测试：代码中包含了对加密过程的性能测试部分，使用time模块来测量代码执行时间。

Project10: report on the application of this deduce technique in Ethereum with ECDSA

运行时间：0.158470 seconds

实现内容：
实现了判断一个数是否为二次剩余（Quadratic Residue）的函数 is_quadratic_residue。
实现了模逆运算的函数 modular_inverse，用于计算模的逆元。
定义了扩展的欧几里得算法函数 extended_gcd，用于计算模的扩展最大公约数。
实现了解决二次剩余的算法函数 solve_quadratic_residue。
实现了生成密钥对的函数 generate_keypair，其中使用了基于随机数生成的私钥和椭圆曲线点乘来生成公钥。
定义了点加法和点倍乘法的函数，用于椭圆曲线上的运算。
实现了生成数字签名的函数 signature_generation，其中使用私钥、消息和随机数生成签名。
实现了从签名推导公钥的函数 deduce_public_key，基于签名信息反推可能的公钥。
通过哈希函数 hash_function，实现了对消息的哈希操作。
在 if __name__ == '__main__': 块中，生成密钥对、生成数字签名、从签名推导公钥，并计算执行时间。

技巧和创新点：
点运算模块化设计： 代码模块化地实现了椭圆曲线上的点加法、点倍乘和点解密等核心运算，使得代码结构清晰，易于维护。
模块化的随机数生成： 使用 secrets 模块生成安全的随机数，确保密钥和随机数的高度安全性。
快速幂和模逆的优化： 使用快速幂算法和模逆计算来优化指数运算和模逆运算，提高了计算效率。
椭圆曲线数学性质的利用： 代码充分利用椭圆曲线的数学性质，如模平方根的求解和扩展欧几里得算法，用于点运算和签名生成。
对称性利用： 在推导公钥的过程中，利用了椭圆曲线的对称性，优化了公钥的计算。
高效的点运算： 代码通过点加法和点倍乘运算，实现了高效的椭圆曲线上的点操作，提高了整体的执行效率。

Project11: impl sm2 with RFC6979

运行时间：0.004743 seconds

实现内容：
导入了 gmssl 库中的 sm2 模块，以及 Python 内置的 hashlib 和 hmac 模块。
定义了 bits2int 函数，用于将字节数据转换为整数。函数将字节数据转换为一个大整数，并将其位数截断或填充以适应给定的位长度。
定义了 bits2octets 函数，将比特数据（bit string）转换为字节序列（octets）。这在 SM2 算法的随机数生成过程中用到。
定义了 generate_k 函数，用于生成符合要求的随机数 k。这个函数在 SM2 数字签名过程中用于生成随机数。函数中使用了 RFC6979 算法生成随机数。
定义了一些参数，包括椭圆曲线的参数、哈希函数、消息、私钥和公钥。
将私钥从十六进制字符串转换为字节数据。
调用 generate_k 函数生成随机数 k。
创建 sm2_crypt 对象，使用 gmssl 库的 CryptSM2 类，初始化了私钥和公钥。
使用私钥对消息进行签名，生成一个数字签名。
使用公钥进行验证，确保生成的数字签名是有效的。

技巧和创新点：
代码中使用了 gmssl 库提供的 CryptSM2 类来简化 SM2 算法的数字签名和验证过程。
使用了位操作和字节序列的转换来处理比特数据和整数之间的转换。

Project12: verify the above pitfalls with proof-of-concept code

ECDSA：

实现内容：
导入了ECDSA模块，用库函数实现ESDSA。
定义了leading_k函数，用于验证Leaking k leads to leaking of d,d=(s*k-e)*pow(r, -1, n))。
定义了reusing_k函数，用于验证Reusing k leads to leaking of d,d=(s*e1-s1*e)*pow((s1-s)*r, -1, n)%n
定义了two_user_k函数，用于验证Two users, using k leads to leaking of d, that is they can deduce each other’s d,d=((s * k - e) * pow(r, -1, n)) % n
将verify(pk, (r, n-s), m)中的s改为n-s，用于验证Malleability, e.g. （r, s) and （r, -s)  are both valid signatures, lead to blockchain network split
定义了forge_sig函数，用于验证One can forge signature if the verification does not check m,.选随机数a、b，计算K=aG+bP2.计算r=X(K)，s=rb−1，e=arb−1，并且定义了verify1函数，用于验证：s−1∗(eG+rP)=r−1b∗(arb−1G+rP)=aG+bP=K，验证通过

创新点与技巧：
深入学习了ecdsa库函数内容，根据有关数学公式，编写对应的POC代码进行证明

Schnorr：

实现内容、创新点与技巧：
基本同于ecdsa的内容，验证思路也近似，额外对Same d and k with ECDSA, leads to leaking of d进行了验证，因为该缺陷对于ecdsa会退化为前边已经证明的内容，故在ecdsa内容中进行了忽略。d= ((s * s1 - e1) * pow(r1 + e * s1, -1, n)) % n。

sm2：与前两个算法的思路基本一致。
13.在此示例中，Alice 生成她的私钥和公钥，而 Bob 生成他的私钥和公钥，将公钥保存到文件中。然后，爱丽丝和鲍勃交换了他们的公钥。Alice 使用她的私钥和 Bob 的公钥计算共享密钥，Bob 使用他的私钥和 Alice 的公钥计算共享密钥。显示了使用椭圆曲线加密生成私钥和公钥的过程，执行ECDH密钥交换以及以PEM格式将公钥保存到从文件中加载的过程。第一个代码段计算并打印从 Alice 的私钥和 Bob 的公钥派生的共享密钥，而第二个代码段生成 Bob 的公钥并将其保存到文件中


14.PGP(Pretty Good Privacy)，是一个基于RSA公钥和对称加密相结合的邮件加密软件。该系统能为电子邮件和文件存储应用过程提供认证业务和保密业务。PGP是个混合加密算法，它由一个对称加密算法、一个非对称加密算法、与单向散列算法以及一个随机数产生器（从用户击键频率产生伪随机数序列的种子）组成本次实验旨在实现一个简易PGP，调用GMSSL库中封装好的SM2/SM4加解密函数。加密时使用对称加密算法SM4加密消息，非对称加密算法SM2加密会话密钥；解密时先使用SM2解密求得会话密钥，再通过SM4和会话密钥求解原消息。加密之前要先对消息进行填充，SM4分组长度为128比特即16个字节，填充完成后，需要将消息m与密钥k转化为bytes类型。调用GMSSL库中封装好的SM4加密函数对信息进行加密


15.SM2 2P 签名协议涉及双方使用 SM2 椭圆曲线加密交换签名消息。一方使用其私钥对消息进行签名，另一方使用签名者的公钥验证签名。此示例演示了 SM2 2P 签名协议，该协议在 Alice（签名者）和 Bob（验证者）之间进行网络通信。Alice 签署一条消息，并将其与她的公钥一起发送给 Bob。Bob 接收消息和 Alice 的公钥，然后验证消息的签名。通信使用套接字通过本地网络进行。


16.SM2 2P 解密协议涉及两方使用 SM2 椭圆曲线加密技术安全地交换加密消息。一方使用收件人的公钥加密邮件，然后收件人使用其私钥解密邮件。此示例展示了 SM2 2P 解密协议的基本实现，该协议在 Alice（发送方）和 Bob（接收方）之间进行网络通信。Alice 向 Bob 发送加密消息，Bob 解密并读取该消息。通信使用套接字通过本地网络进行。

18：
代码是一个Python脚本，用于在比特币测试网络上发送一笔交易，并解析该交易的数据。下面对代码进行简单的介绍：

1. 首先，代码导入了`bitcoinrpc.authproxy`模块，这是一个用于连接到比特币节点并与其进行通信的库。

2. 接着，脚本中定义了`rpc_user`、`rpc_password`和`rpc_port`，这些是您的比特币节点的RPC凭据和端口号。

3. `send_testnet_transaction`函数用于发送一笔比特币交易到指定的测试网络地址。需要将`to_address`替换为想要发送比特币的测试网络地址。

4. `parse_transaction_data`函数用于解析交易的原始数据，并以字典的形式返回交易的各个字段，包括版本号、大小、输入、输出和锁定时间。

5. 在`__name__ == "__main__"`部分，代码将发送一笔测试网络交易，并将交易数据解析为每一个字段。然后，打印交易ID和解析后的交易数据。

6. 异常处理部分，如果在发送交易或解析数据时发生错误，会打印错误信息。

19：
未能完成伪造数字签名的任务，了解了数字签名防止被伪造的点：
真实性：数字签名能够验证消息或数据的真实性。只有特定的实体（例如某个人或组织）拥有与数字签名配对的私钥，才能对消息进行签名。接收方可以使用公钥验证签名的有效性，从而确认消息确实来自所声称的实体。
完整性：数字签名可以确保数据在传输过程中没有被篡改或修改。在签名前，消息首先会通过哈希函数生成一个固定长度的哈希值。接收方在验证签名时，会再次计算哈希值，并与签名中的哈希值进行比对。如果哈希值匹配，就表示数据完整且未被篡改。
不可否认性：数字签名可以确保消息的发送方不能否认已经发送过该消息。由于数字签名是使用私钥生成的，发送方无法否认签名的有效性，从而避免发生抵赖行为。

20：
重复

21：
代码实现了Schnorr签名算法及其批量验证。Schnorr签名算法是一种用于数字签名的加密算法，具有高效性和安全性。下面是对代码的简单介绍：

1. `schnorr_sign`函数用于生成Schnorr签名。它接受私钥和消息作为输入，并返回Schnorr签名的两个值：R和s。其中，R是签名的一部分，而s是用于验证签名的另一部分。

2. `schnorr_verify`函数用于验证Schnorr签名的有效性。它接受公钥、消息、R和s作为输入，并验证签名是否正确。

3. `schnorr_batch_verify`函数是一个批量验证函数，用于同时验证多个Schnorr签名的有效性。它接受公钥、消息列表、R列表和s列表作为输入，并在一次计算中验证所有签名的有效性。

4. 示例用法部分生成一个私钥和公钥，然后生成多个消息，并使用私钥对每个消息进行签名。接着，提取每个签名的R和s，并使用批量验证函数`schnorr_batch_verify`来验证这些签名的有效性。

Schnorr签名算法被广泛认为是一种高效且安全的签名算法，它具有很多优势，如简洁性、线性性能、抵抗侧信道攻击等。请注意，此代码仅用于教学示例，实际应用中需要考虑更多的安全细节和错误处理。

总结：
可以学到以下几点：
1. 学习Schnorr签名算法：这两个代码展示了Schnorr签名算法的实现。Schnorr签名算法是一种高效且安全的数字签名算法，学习该算法可以了解其工作原理和应用。
2. 理解数字签名的基本原理：通过这些代码，可以深入理解数字签名的基本原理，包括如何生成签名和如何验证签名。数字签名是确保数据真实性、完整性和认证的关键机制。
3. 掌握哈希函数的使用：在签名过程中，这些代码使用SHA256哈希函数对消息进行哈希处理。哈希函数用于生成消息的唯一指纹，以确保数据在传输过程中不被篡改。
4. 批量验证的优势：`schnorr_batch_verify`函数展示了批量验证多个签名的方法，通过合并验证操作，可以提高验证效率。在处理大量签名时，批量验证对于性能优化很有帮助。
5. 代码的结构和实现：这些代码展示了如何使用Python实现Schnorr签名算法和批量验证功能。学习代码的结构和实现可以帮助了解如何在编程中应用密码学算法。
